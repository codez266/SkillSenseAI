import logging
import json
import pdb

from peewee import fn
from adaptive_concept_selection.db.db_utils import init_test_db
from adaptive_concept_selection.question_generation.question_generation_cg import SimulatedStudentExperiment
from adaptive_concept_selection.db.models import database_proxy as acs_db_proxy

from flask import Blueprint, jsonify, session, request, current_app
from datetime import datetime
from db.models import Student, StudentInterviewRecord, InterviewConversation, Artifact, database_proxy
from db.config import CONFIG

bp = Blueprint('interview', __name__, url_prefix='/api')

def get_interview_details():
    interview_id = session.get('interview_id')
    if not interview_id:
        return jsonify({'error': 'Interview ID not found'}), 400, None, None
    try:
        interview_record = StudentInterviewRecord.select().where(StudentInterviewRecord.interview_id==interview_id).get_or_none()
    except Exception:
        return jsonify({'error': 'Interview not found'}), 400, None, None
    return None, interview_id, interview_record, None

@bp.route('/interview', defaults={'student_type': None}, methods=['GET'])
@bp.route('/interview/<string:student_type>', methods=['GET'])
def interview(student_type):
    types = ['beginner', 'intermediate', 'advanced']
    # If student type is provided in a route, it should be one of the types.
    # If not provided, a student with a None type is created to be estimated later.
    # TODO: populate problem from the request, or load from a random sample of # problems from the db.
    # TODO: Have a post method that also submits a problem to the interview.
    if student_type not in types and student_type:
        return jsonify({
            'error': 'Invalid student type'
        }), 400

    try:
        # Check if we already have a student_type_id in session
        student_type_id = session.get('student_type_id')
        interview_id = session.get('interview_id')

        if student_type_id and interview_id:
            return jsonify({
                'student_type_id': student_type_id,
                'interview_id': interview_id
            }), 200

        # Create a new student with default values
        student = Student.create(
            student_level=student_type,
            student_k_cs=None,
            student_type_id=None,  # This will be auto-generated by the database
        )
        student.save()

        artifact_id = None
        if student_type:
            # Sample an artifact for the student
            artifact = Artifact.select().where(
                Artifact.artifact_level == student_type
            ).order_by(fn.Random()).limit(1).get_or_none()
            artifact_id = artifact.artifact_id if artifact else None

            if not artifact:
                return jsonify({
                'error': 'No artifact found for the given student type'
            }), 400

        # Create an interview record for this student
        interview = StudentInterviewRecord.create(
            interview_student_type_id=student.student_type_id,
            interview_timestamp=datetime.now(),
            interview_metadata=None,
            interview_problem_id=artifact_id,
            interview_policy=None
        )
        interview.save()

        # Store IDs in session
        session['student_type_id'] = student.student_type_id
        session['interview_id'] = interview.interview_id

        return jsonify({
            'student_type_id': student.student_type_id,
            'interview_id': interview.interview_id
        }), 201

    except Exception as e:
        current_app.logger.error(f"Error creating interview: {str(e)}")
        return jsonify({
            'error': str(e)
        }), 500

@bp.route('/conversation/interviewer', methods=['GET'])
def conversation_interviewer():
    error_response, interview_id, interview_record, _ = get_interview_details()
    if error_response:
        return error_response
    # Get the conversation
    # conversations = InterviewConversation.select().where(
    #     InterviewConversation.conversation_interview_id == interview_id
    # ).order_by(InterviewConversation.conversation_turn_id)

    # Now we have the interview_id, the student problem, and the conversation so far.
    # We need to generate a question for the interviewer.
    # Pass this data to a model that generates a question for the interviewer, records the question, and returns the question.
    # TODO: question = generate_question(interview_id, student_problem, conversation)

    # This will resume the experiment with the given interview_id
    #simulator = current_app.config["simulator"]
    creds_file = "azure_auth.json"
    simulator = current_app.config["simulator"]
    acs_db_proxy.initialize(simulator.db)
    # simulator = SimulatedStudentExperiment(logger=current_app.logger, test_db=current_app.db, db_config=CONFIG, llm_creds=creds_file, simulation=True)
    obs, _ = simulator.reset(interview_id)
    obs, _, done, _, _ = simulator.step()
    if done:
        return jsonify({
            "status": "Interview has already ended."
        }), 200
    conversations = obs["conversation_history"]
    last_response = conversations[-1] if conversations else None
    last_reply = last_response.conversation_response if last_response else None
    last_metadata = json.loads(
        last_response.conversation_metadata if last_response else {})

    # Return the question
    return jsonify({
        "question": last_reply,
        "metadata": last_metadata,
        "status": "success"
    }), 200


@bp.route('/conversation/student', methods=['POST'])
def conversation_student():
    error_response, interview_id, interview, _ = get_interview_details()
    if error_response:
        return error_response
    student_answer = request.json.get("response")
    simulator = current_app.config["simulator"]
    acs_db_proxy.initialize(simulator.db)
    # This will resume the experiment with the given interview_id
    obs, _ = simulator.reset(interview_id)
    obs, _, done, _, _ = simulator.step(student_answer)
    conversations = obs["conversation_history"]

    last_response = conversations[-1] if conversations else None
    last_reply = last_response.conversation_response if last_response else None
    reference_answer = last_response.conversation_reference if last_response else None
    last_metadata = json.loads(
        last_response.conversation_metadata if last_response else {})

    # Return the question
    return jsonify({
        "answer": last_reply,
        "reference_answer": reference_answer,
        "metadata": last_metadata,
        "status": "success"
    }), 200
